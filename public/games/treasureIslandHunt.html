<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mirror Mirror: Geometry Reflection</title>

    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        body {
            font-family: 'Lato', sans-serif;
            background-color: #0f0720;
            /* Deep Purple */
            color: #e9d5ff;
            /* Purple 200 */
            overflow-x: hidden;
        }

        .font-magic {
            font-family: 'Cinzel', serif;
        }

        /* Grid Glow Effects */
        .axis-glow {
            filter: drop-shadow(0 0 5px #c084fc);
        }

        .mirror-line {
            stroke: #e879f9;
            stroke-width: 0.15;
            filter: drop-shadow(0 0 8px #d946ef);
            stroke-dasharray: 0.5 0.2;
            animation: shimmer 3s linear infinite;
        }

        @keyframes shimmer {
            0% {
                stroke-dashoffset: 0;
                opacity: 0.8;
            }

            50% {
                opacity: 1;
            }

            100% {
                stroke-dashoffset: 2;
                opacity: 0.8;
            }
        }

        .point-glow {
            animation: pulse-point 2s infinite;
        }

        @keyframes pulse-point {
            0% {
                r: 0.2;
                opacity: 0.6;
                stroke-width: 0.05;
            }

            50% {
                r: 0.3;
                opacity: 1;
                stroke-width: 0.1;
            }

            100% {
                r: 0.2;
                opacity: 0.6;
                stroke-width: 0.05;
            }
        }

        .success-flash {
            animation: flash 0.5s ease-out;
        }

        @keyframes flash {
            0% {
                background-color: rgba(232, 121, 249, 0.3);
            }

            100% {
                background-color: transparent;
            }
        }

        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(30, 20, 50, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">

        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const Sparkles = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-fuchsia-400"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" /></svg>
        );
        const RefreshCw = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></svg>
        );
        const CheckCircle = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-green-400"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></svg>
        );

        // --- Game Logic ---

        // Grid goes from -8 to +8
        const GRID_RANGE = 8;

        const generateLevel = (difficulty) => {
            // Generate a random polygon on the LEFT side (x < 0)
            // Points should be integers
            const numPoints = difficulty === 1 ? 3 : difficulty === 2 ? 4 : 5;
            const points = [];

            // Helper to ensure points aren't too close or collinear (simple check)
            const usedCoords = new Set();

            while (points.length < numPoints) {
                const x = -Math.floor(Math.random() * (GRID_RANGE - 2)) - 2; // -2 to -8
                const y = Math.floor(Math.random() * (GRID_RANGE * 2)) - GRID_RANGE; // -8 to 8
                const key = `${x},${y}`;

                if (!usedCoords.has(key)) {
                    points.push({ x, y });
                    usedCoords.add(key);
                }
            }

            // Sort points to make a relatively nice polygon (e.g., clockwise around center)
            // Simple center calculation
            const cx = points.reduce((s, p) => s + p.x, 0) / points.length;
            const cy = points.reduce((s, p) => s + p.y, 0) / points.length;

            points.sort((a, b) => {
                return Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx);
            });

            return {
                original: points,
                // The expected reflection is just (-x, y)
                reflection: points.map(p => ({ x: -p.x, y: p.y }))
            };
        };

        const Grid = ({
            levelData,
            userPoints,
            onPointClick,
            nextTargetIndex,
            isComplete
        }) => {
            const [hoverPos, setHoverPos] = useState(null);

            // ViewBox Setup
            // Logical range: -GRID_RANGE to +GRID_RANGE
            // We want 0,0 in center.
            // Let's map logical coordinates to SVG 0-100 range for ease.
            const size = 100;
            const padding = 10;
            const availableSize = size - (2 * padding);
            const unit = availableSize / (GRID_RANGE * 2);

            const toSvg = (x, y) => ({
                x: padding + (x + GRID_RANGE) * unit,
                y: padding + (GRID_RANGE - y) * unit // Flip Y for SVG
            });

            // Reverse mapping for clicks
            const fromSvg = (svgX, svgY) => {
                const relX = svgX - padding;
                const relY = svgY - padding;
                const gridX = Math.round(relX / unit) - GRID_RANGE;
                const gridY = GRID_RANGE - Math.round(relY / unit);
                return { x: gridX, y: gridY };
            };

            const handleMouseMove = (e) => {
                const rect = e.target.getBoundingClientRect();
                // Calculate raw SVG coordinates 0-100
                const scaleX = size / rect.width;
                const scaleY = size / rect.height;
                const rawX = (e.clientX - rect.left) * scaleX;
                const rawY = (e.clientY - rect.top) * scaleY;

                const gridPos = fromSvg(rawX, rawY);

                // Clamp to grid
                if (gridPos.x >= -GRID_RANGE && gridPos.x <= GRID_RANGE &&
                    gridPos.y >= -GRID_RANGE && gridPos.y <= GRID_RANGE) {
                    setHoverPos(gridPos);
                } else {
                    setHoverPos(null);
                }
            };

            const handleClick = () => {
                if (hoverPos && !isComplete) {
                    onPointClick(hoverPos);
                }
            };

            // --- Render Helpers ---

            // Grid Lines
            const gridLines = [];
            const labels = [];

            for (let i = -GRID_RANGE; i <= GRID_RANGE; i++) {
                const p1 = toSvg(i, -GRID_RANGE);
                const p2 = toSvg(i, GRID_RANGE);
                const p3 = toSvg(-GRID_RANGE, i);
                const p4 = toSvg(GRID_RANGE, i);

                const isAxis = i === 0;
                const opacity = isAxis ? 1 : 0.15;
                const color = isAxis ? (i === 0 ? "#e879f9" : "#c084fc") : "#a855f7";
                const width = isAxis ? 0.8 : 0.3;

                // Vertical
                gridLines.push(<line key={`v${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={color} strokeWidth={width} opacity={opacity} className={isAxis ? "mirror-line" : ""} />);

                // Horizontal
                if (i !== 0) // Skip X axis drawing over Y axis logic if strictly visual
                    gridLines.push(<line key={`h${i}`} x1={p3.x} y1={p3.y} x2={p4.x} y2={p4.y} stroke="#c084fc" strokeWidth={isAxis ? 0.8 : 0.3} opacity={isAxis ? 0.8 : 0.15} />);

                // Axis Labels
                if (i !== 0 && i % 2 === 0) {
                    const lx = toSvg(i, 0);
                    const ly = toSvg(0, i);
                    labels.push(<text key={`xl${i}`} x={lx.x} y={lx.y + 3} fontSize="3" fill="#c084fc" textAnchor="middle" opacity="0.7">{i}</text>);
                    labels.push(<text key={`yl${i}`} x={ly.x - 2} y={ly.y + 1} fontSize="3" fill="#c084fc" textAnchor="end" opacity="0.7">{i}</text>);
                }
            }

            // Original Shape
            const originalPointsSvg = levelData.original.map(p => {
                const s = toSvg(p.x, p.y);
                return `${s.x},${s.y}`;
            }).join(" ");

            // Highlight the specific vertex we are trying to mirror right now
            const targetVertex = !isComplete ? levelData.original[nextTargetIndex] : null;

            // User's Drawn Shape (so far)
            // We want to draw lines connecting the user points in order
            // But we might want to close the loop only if complete
            const userPath = userPoints.map(p => {
                const s = toSvg(p.x, p.y);
                return `${s.x},${s.y}`;
            }).join(" ");

            return (
                <div className="relative w-full aspect-square max-w-xl mx-auto select-none cursor-crosshair">
                    <svg
                        viewBox={`0 0 ${size} ${size}`}
                        className="w-full h-full glass-panel rounded-xl shadow-2xl"
                        onMouseMove={handleMouseMove}
                        onClick={handleClick}
                        onMouseLeave={() => setHoverPos(null)}
                    >
                        {/* Grid */}
                        {gridLines}
                        {labels}

                        {/* Mirror Axis Label */}
                        <text x={size / 2} y={3} fontSize="3" fill="#e879f9" textAnchor="middle" className="font-magic">Mirror (Y-Axis)</text>

                        {/* Original Shape */}
                        <polygon points={originalPointsSvg} fill="rgba(59, 130, 246, 0.2)" stroke="#3b82f6" strokeWidth="0.5" />
                        {levelData.original.map((p, i) => {
                            const s = toSvg(p.x, p.y);
                            const isTarget = targetVertex && p.x === targetVertex.x && p.y === targetVertex.y;
                            return (
                                <g key={`orig-${i}`}>
                                    <circle cx={s.x} cy={s.y} r={isTarget ? 1.5 : 0.8} fill="#3b82f6" className={isTarget ? "point-glow" : ""} />
                                    {isTarget && (
                                        <circle cx={s.x} cy={s.y} r={2.5} stroke="#3b82f6" strokeWidth="0.2" fill="none" className="animate-ping" />
                                    )}
                                </g>
                            );
                        })}

                        {/* User Shape */}
                        {userPoints.length > 0 && (
                            <path d={`M ${userPoints.map(p => `${toSvg(p.x, p.y).x} ${toSvg(p.x, p.y).y}`).join(' L ')} ${isComplete ? 'Z' : ''}`} fill={isComplete ? "rgba(232, 121, 249, 0.2)" : "none"} stroke="#e879f9" strokeWidth="0.5" />
                        )}
                        {userPoints.map((p, i) => {
                            const s = toSvg(p.x, p.y);
                            return <circle key={`user-${i}`} cx={s.x} cy={s.y} r="0.8" fill="#e879f9" />;
                        })}

                        {/* Ghost/Hover Point */}
                        {hoverPos && !isComplete && (
                            <circle cx={toSvg(hoverPos.x, hoverPos.y).x} cy={toSvg(hoverPos.x, hoverPos.y).y} r="1" fill="rgba(255,255,255,0.5)" />
                        )}

                    </svg>

                    {/* Coordinate Tooltip */}
                    <div className="absolute top-4 left-4 font-mono text-sm bg-black/60 px-3 py-1 rounded border border-purple-500/30 text-purple-200 pointer-events-none">
                        {hoverPos ? `(${hoverPos.x}, ${hoverPos.y})` : "Hover grid..."}
                    </div>

                    {/* Instruction Overlay */}
                    {!isComplete && targetVertex && (
                        <div className="absolute bottom-4 left-1/2 -translate-x-1/2 bg-black/80 px-4 py-2 rounded-full border border-blue-500 text-blue-200 text-sm font-bold shadow-lg pointer-events-none whitespace-nowrap">
                            Reflect point <span className="text-white">({targetVertex.x}, {targetVertex.y})</span>
                        </div>
                    )}
                </div>
            );
        };

        const App = () => {
            const [difficulty, setDifficulty] = useState(1);
            const [levelData, setLevelData] = useState(null);
            const [userPoints, setUserPoints] = useState([]);
            const [feedback, setFeedback] = useState("");
            const [score, setScore] = useState(0);
            const [isComplete, setIsComplete] = useState(false);
            const [shake, setShake] = useState(false);

            // Initialize
            useEffect(() => {
                startNewLevel();
            }, [difficulty]);

            const startNewLevel = () => {
                const data = generateLevel(difficulty);
                setLevelData(data);
                setUserPoints([]);
                setIsComplete(false);
                setFeedback("Tap the grid to reflect the highlighted point.");
            };

            const handlePointClick = (pos) => {
                if (isComplete) return;

                // The point user *should* click
                const targetIndex = userPoints.length;
                const targetOriginal = levelData.original[targetIndex];
                const expectedReflection = { x: -targetOriginal.x, y: targetOriginal.y };

                if (pos.x === expectedReflection.x && pos.y === expectedReflection.y) {
                    // Correct
                    const newPoints = [...userPoints, pos];
                    setUserPoints(newPoints);

                    // Check if level complete
                    if (newPoints.length === levelData.original.length) {
                        setIsComplete(true);
                        setFeedback("Mirror Image Complete!");
                        setScore(s => s + (difficulty * 100));
                    } else {
                        setFeedback("Correct! Find the next point.");
                    }
                } else {
                    // Incorrect
                    setFeedback("The mirror reflects across the Y-axis. Try again!");
                    setShake(true);
                    setTimeout(() => setShake(false), 500);
                }
            };

            if (!levelData) return <div className="text-white p-10">Summoning Mirror...</div>;

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4 relative bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-900 via-purple-950 to-black">

                    {/* Header */}
                    <div className="text-center mb-6 z-10">
                        <h1 className="text-4xl md:text-6xl font-magic text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-300 to-purple-400 drop-shadow-[0_0_10px_rgba(192,132,252,0.5)] flex items-center justify-center gap-4">
                            <Sparkles /> Mirror Mirror <Sparkles />
                        </h1>
                        <p className="text-purple-300/70 mt-2 font-mono text-sm tracking-widest uppercase">Reflect the shape across the Y-Axis</p>
                    </div>

                    <div className="w-full max-w-4xl grid grid-cols-1 md:grid-cols-3 gap-8 items-start z-10">

                        {/* Left Panel: Info & Stats */}
                        <div className="glass-panel p-6 rounded-xl text-center md:text-left order-2 md:order-1">
                            <div className="mb-6">
                                <h3 className="text-xs uppercase text-purple-400 font-bold mb-1">Current Score</h3>
                                <div className="text-3xl font-magic text-white">{score}</div>
                            </div>

                            <div className="mb-6">
                                <h3 className="text-xs uppercase text-purple-400 font-bold mb-2">Difficulty</h3>
                                <div className="flex gap-2 justify-center md:justify-start">
                                    {[1, 2, 3].map(lvl => (
                                        <button
                                            key={lvl}
                                            onClick={() => setDifficulty(lvl)}
                                            className={`w-8 h-8 rounded-full font-bold border ${difficulty === lvl ? 'bg-fuchsia-600 border-fuchsia-400 text-white shadow-[0_0_10px_#c026d3]' : 'bg-transparent border-purple-800 text-purple-800 hover:border-purple-500 hover:text-purple-500'}`}
                                        >
                                            {lvl}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="p-3 bg-purple-900/30 rounded border border-purple-700/50 text-sm text-purple-200 italic">
                                "Remember: The reflection of (x, y) across the Y-axis is (-x, y)."
                            </div>
                        </div>

                        {/* Center: The Grid */}
                        <div className={`md:col-span-2 order-1 md:order-2 ${shake ? 'animate-bounce' : ''}`}>
                            <div className={`relative rounded-xl p-1 transition-colors duration-500 ${isComplete ? 'bg-gradient-to-r from-green-400 to-emerald-600 shadow-[0_0_30px_rgba(34,197,94,0.4)]' : 'bg-gradient-to-b from-purple-700 to-fuchsia-900 shadow-[0_0_30px_rgba(168,85,247,0.2)]'}`}>
                                {isComplete && <div className="absolute inset-0 z-0 bg-white/20 success-flash rounded-xl pointer-events-none"></div>}

                                <Grid
                                    levelData={levelData}
                                    userPoints={userPoints}
                                    onPointClick={handlePointClick}
                                    nextTargetIndex={userPoints.length}
                                    isComplete={isComplete}
                                />

                                {/* Status Bar */}
                                <div className="absolute -bottom-12 left-0 right-0 text-center">
                                    <div className={`inline-block px-6 py-2 rounded-full backdrop-blur-md border shadow-lg font-bold transition-all duration-300 ${feedback.includes("Correct") || feedback.includes("Complete")
                                            ? "bg-green-900/40 border-green-500 text-green-300"
                                            : feedback.includes("Try again")
                                                ? "bg-red-900/40 border-red-500 text-red-300"
                                                : "bg-purple-900/40 border-purple-500 text-purple-200"
                                        }`}>
                                        {feedback}
                                    </div>
                                </div>
                            </div>

                            {/* Next Level Button */}
                            {isComplete && (
                                <div className="mt-16 flex justify-center">
                                    <button
                                        onClick={startNewLevel}
                                        className="bg-gradient-to-r from-fuchsia-600 to-purple-600 hover:from-fuchsia-500 hover:to-purple-500 text-white font-bold py-3 px-8 rounded-full shadow-lg flex items-center gap-2 transform transition hover:scale-105 active:scale-95 font-magic tracking-wider"
                                    >
                                        <RefreshCw /> Next Reflection
                                    </button>
                                </div>
                            )}
                        </div>

                    </div>

                    <div className="mt-12 text-purple-500/40 text-xs text-center z-10">
                        Skill Target: LL.4 (Graphing Shapes & Reflection) â€¢ 5th Grade Math
                    </div>

                    {/* Background Particles (Simple static CSS for atmosphere) */}
                    <div className="fixed top-20 left-20 w-1 h-1 bg-white rounded-full shadow-[0_0_10px_white] opacity-50 animate-pulse"></div>
                    <div className="fixed bottom-40 right-40 w-2 h-2 bg-fuchsia-400 rounded-full shadow-[0_0_15px_magenta] opacity-30 animate-pulse" style={{ animationDuration: '3s' }}></div>
                    <div className="fixed top-1/2 left-10 w-1 h-1 bg-purple-300 rounded-full opacity-40"></div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>