<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Radar: Pattern Defense</title>

    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #020617;
            /* Slate 950 */
            color: #4ade80;
            /* Green 400 */
            overflow-x: hidden;
        }

        .font-pixel {
            font-family: 'VT323', monospace;
        }

        /* CRT Screen Effects */
        .crt-container {
            position: relative;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9);
            border: 2px solid #334155;
            background: radial-gradient(circle, #0f1f14 0%, #000000 100%);
        }

        .scan-line {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50%;
            height: 2px;
            background: rgba(74, 222, 128, 0.8);
            transform-origin: 0% 0%;
            animation: radar-spin 4s linear infinite;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.8);
            pointer-events: none;
            z-index: 10;
        }

        @keyframes radar-spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .blip {
            animation: blip-fade 2s infinite;
        }

        @keyframes blip-fade {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.4;
                transform: scale(1.2);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .grid-glow {
            filter: drop-shadow(0 0 2px rgba(74, 222, 128, 0.3));
        }

        /* Input styling */
        .coord-input {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #166534;
            color: #4ade80;
            text-align: center;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            width: 3rem;
        }

        .coord-input:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }

        /* Glitch effect for Game Over */
        .glitch {
            animation: glitch-anim 0.3s infinite;
        }

        @keyframes glitch-anim {
            0% {
                transform: translate(0);
            }

            20% {
                transform: translate(-2px, 2px);
            }

            40% {
                transform: translate(-2px, -2px);
            }

            60% {
                transform: translate(2px, 2px);
            }

            80% {
                transform: translate(2px, -2px);
            }

            100% {
                transform: translate(0);
            }
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">

        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const SkullIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="w-full h-full text-red-500"><path d="M12 2c-4 0-8 3-8 9 0 4 3 7 5 7.5V22h6v-3.5c2-.5 5-3.5 5-7.5 0-6-4-9-8-9z" /><path d="M9 13a1 1 0 1 0 0-2 1 1 0 0 0 0 2z" /><path d="M15 13a1 1 0 1 0 0-2 1 1 0 0 0 0 2z" /><path d="M12 17v1" /></svg>
        );
        const TrapIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="w-full h-full text-yellow-400"><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" /><path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" /><path d="M6 12h2" /><path d="M16 12h2" /><path d="M12 6v2" /><path d="M12 16v2" /></svg>
        );
        const CrosshairIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="w-6 h-6"><circle cx="12" cy="12" r="10" /><line x1="22" y1="12" x2="18" y2="12" /><line x1="6" y1="12" x2="2" y2="12" /><line x1="12" y1="6" x2="12" y2="2" /><line x1="12" y1="22" x2="12" y2="18" /></svg>
        );

        // --- Game Logic ---
        const GRID_SIZE = 12;

        const generatePattern = (level) => {
            // Determine complexity based on level
            let dx, dy, startX, startY;

            // Safety loop to ensure we can have at least 6 points (3 history + 3 future)
            let valid = false;
            let attempts = 0;

            while (!valid && attempts < 100) {
                attempts++;

                // Randomize Slope (dx, dy)
                if (level === 1) {
                    dx = Math.random() > 0.5 ? 1 : 0;
                    dy = dx === 0 ? 1 : (Math.random() > 0.5 ? 1 : 0);
                    if (dx === 0 && dy === 0) dy = 1;
                } else if (level <= 3) {
                    dx = Math.floor(Math.random() * 2); // 0 or 1
                    dy = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                    if (dx === 0 && dy === 0) dx = 1;
                } else {
                    dx = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                    dy = Math.floor(Math.random() * 3) - 1;
                    if (dx === 0 && dy === 0) dx = 1;
                }

                // Randomize Start
                startX = Math.floor(Math.random() * GRID_SIZE);
                startY = Math.floor(Math.random() * GRID_SIZE);

                // Check if 6 steps fit in grid (0 to GRID_SIZE)
                const endX = startX + (dx * 5);
                const endY = startY + (dy * 5);

                if (endX >= 0 && endX <= GRID_SIZE && endY >= 0 && endY <= GRID_SIZE) {
                    valid = true;
                }
            }

            // Generate the points
            const points = [];
            for (let i = 0; i < 6; i++) {
                points.push({ x: startX + (dx * i), y: startY + (dy * i) });
            }

            return {
                history: points.slice(0, 3),
                future: points.slice(3, 6),
                pattern: { dx, dy }
            };
        };


        const RadarGrid = ({ history, deployedTraps, zombiePath, gridSize }) => {
            const padding = 1;
            const viewBoxSize = gridSize + 2 * padding;

            const toSvg = (x, y) => ({
                x: x + padding,
                y: (gridSize - y) + padding
            });

            // Generate grid lines
            const lines = [];
            for (let i = 0; i <= gridSize; i++) {
                const hStart = toSvg(0, i);
                const hEnd = toSvg(gridSize, i);
                const vStart = toSvg(i, 0);
                const vEnd = toSvg(i, gridSize);

                lines.push(<line key={`h${i}`} x1={hStart.x} y1={hStart.y} x2={hEnd.x} y2={hEnd.y} stroke="#14532d" strokeWidth="0.05" />);
                lines.push(<line key={`v${i}`} x1={vStart.x} y1={vStart.y} x2={vEnd.x} y2={vEnd.y} stroke="#14532d" strokeWidth="0.05" />);

                // Labels
                if (i % 2 === 0) { // Reduce label clutter
                    lines.push(<text key={`xl${i}`} x={vStart.x} y={vStart.y + 0.5} fontSize="0.4" fill="#22c55e" textAnchor="middle" opacity="0.7">{i}</text>);
                    lines.push(<text key={`yl${i}`} x={hStart.x - 0.2} y={hStart.y + 0.15} fontSize="0.4" fill="#22c55e" textAnchor="end" opacity="0.7">{i}</text>);
                }
            }

            return (
                <div className="crt-container rounded-full aspect-square w-full overflow-hidden relative shadow-[0_0_20px_rgba(34,197,94,0.3)]">
                    <div className="scan-line"></div>

                    {/* Overlay Grid mesh effect */}
                    <div className="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSJyZ2JhKDAsIDUwLCAwLCAwLjIpIi8+Cjwvc3ZnPg==')] opacity-50 pointer-events-none"></div>

                    <svg viewBox={`0 0 ${viewBoxSize} ${viewBoxSize}`} className="w-full h-full relative z-10 grid-glow">
                        {lines}

                        {/* History Points (Zombie Blips) */}
                        {history.map((pt, i) => {
                            const pos = toSvg(pt.x, pt.y);
                            return (
                                <g key={`hist-${i}`}>
                                    <circle cx={pos.x} cy={pos.y} r="0.3" fill="#ef4444" className="blip" />
                                    <circle cx={pos.x} cy={pos.y} r="0.5" stroke="#ef4444" strokeWidth="0.05" fill="none" opacity="0.5" />
                                </g>
                            );
                        })}

                        {/* Deployed Traps */}
                        {deployedTraps.map((pt, i) => {
                            const pos = toSvg(pt.x, pt.y);
                            return (
                                <g key={`trap-${i}`}>
                                    <rect x={pos.x - 0.25} y={pos.y - 0.25} width="0.5" height="0.5" fill="none" stroke="#facc15" strokeWidth="0.1" />
                                    <line x1={pos.x - 0.2} y1={pos.y - 0.2} x2={pos.x + 0.2} y2={pos.y + 0.2} stroke="#facc15" strokeWidth="0.1" />
                                    <line x1={pos.x + 0.2} y1={pos.y - 0.2} x2={pos.x - 0.2} y2={pos.y + 0.2} stroke="#facc15" strokeWidth="0.1" />
                                </g>
                            );
                        })}

                        {/* Full Zombie Path (Revealed on Game Over or Success) */}
                        {zombiePath && zombiePath.map((pt, i) => {
                            if (i < 3) return null; // Skip history
                            const pos = toSvg(pt.x, pt.y);
                            return (
                                <circle key={`full-${i}`} cx={pos.x} cy={pos.y} r="0.2" fill="#ef4444" opacity="0.5" />
                            );
                        })}
                    </svg>

                    {/* Center Crosshair */}
                    <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-green-500/30 pointer-events-none">
                        <svg width="100" height="100" viewBox="0 0 100 100" fill="none" stroke="currentColor">
                            <circle cx="50" cy="50" r="48" strokeWidth="1" />
                            <circle cx="50" cy="50" r="30" strokeWidth="1" />
                            <line x1="50" y1="0" x2="50" y2="100" strokeWidth="0.5" />
                            <line x1="0" y1="50" x2="100" y2="50" strokeWidth="0.5" />
                        </svg>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [gameData, setGameData] = useState(null);
            const [inputs, setInputs] = useState([{ x: '', y: '' }, { x: '', y: '' }, { x: '', y: '' }]);
            const [gameState, setGameState] = useState('planning'); // planning, deploying, breach, secure
            const [feedback, setFeedback] = useState("Analyze movement. Predict next 3 steps.");

            // Initial Load
            useEffect(() => {
                startLevel(1);
            }, []);

            const startLevel = (lvl) => {
                const data = generatePattern(lvl);
                setGameData(data);
                setInputs([{ x: '', y: '' }, { x: '', y: '' }, { x: '', y: '' }]);
                setGameState('planning');
                setFeedback("Analyze movement. Predict next 3 steps.");
            };

            const handleInputChange = (index, field, value) => {
                if (gameState !== 'planning') return;
                const newInputs = [...inputs];
                // Allow only numbers
                if (value === '' || /^-?\d*$/.test(value)) {
                    newInputs[index][field] = value;
                    setInputs(newInputs);
                }
            };

            const deployTraps = () => {
                // Validate inputs are filled
                if (inputs.some(inp => inp.x === '' || inp.y === '')) {
                    setFeedback("ERROR: Coordinates incomplete. Trap sequence aborted.");
                    return;
                }

                setGameState('deploying');
                setFeedback("Deploying countermeasures...");

                setTimeout(() => {
                    // Check Logic
                    let allCorrect = true;
                    inputs.forEach((inp, idx) => {
                        const target = gameData.future[idx];
                        if (parseInt(inp.x) !== target.x || parseInt(inp.y) !== target.y) {
                            allCorrect = false;
                        }
                    });

                    if (allCorrect) {
                        setGameState('secure');
                        setScore(s => s + 100 + (level * 50));
                        setFeedback("TARGET NEUTRALIZED. Area Secure.");
                    } else {
                        setGameState('breach');
                        setFeedback("CALCULATION ERROR. Perimeter Breached!");
                    }
                }, 1500); // Suspense delay
            };

            const nextMission = () => {
                setLevel(l => l + 1);
                startLevel(level + 1);
            };

            const retryMission = () => {
                setScore(0);
                setLevel(1);
                startLevel(1);
            };

            if (!gameData) return <div className="text-green-500 font-mono p-10">Initializing Radar...</div>;

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4 relative">

                    {/* Header */}
                    <header className="w-full max-w-4xl flex justify-between items-end border-b border-green-800 pb-4 mb-6 z-10">
                        <div>
                            <h1 className="text-4xl md:text-5xl font-pixel text-green-400 drop-shadow-[0_0_10px_rgba(74,222,128,0.5)] uppercase">
                                Zombie Radar
                            </h1>
                            <div className="flex gap-4 text-xs font-mono text-green-600 mt-1">
                                <span>SYS: ONLINE</span>
                                <span>GRID: {GRID_SIZE}x{GRID_SIZE}</span>
                                <span>DEFCON: 4</span>
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-xs text-green-700 uppercase">Score</div>
                            <div className="text-3xl font-pixel text-green-300">{score.toString().padStart(6, '0')}</div>
                        </div>
                    </header>

                    <div className="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-2 gap-8 items-center z-10">

                        {/* Left: Radar Display */}
                        <div className="relative p-4">
                            {gameState === 'breach' && (
                                <div className="absolute inset-0 z-20 flex items-center justify-center bg-red-900/40 rounded-full glitch pointer-events-none">
                                    <span className="text-red-500 font-bold text-6xl font-pixel border-4 border-red-500 p-4 bg-black/80">BREACH</span>
                                </div>
                            )}
                            {gameState === 'secure' && (
                                <div className="absolute inset-0 z-20 flex items-center justify-center pointer-events-none">
                                    <span className="text-green-400 font-bold text-6xl font-pixel border-4 border-green-400 p-4 bg-black/80 animate-bounce">SECURE</span>
                                </div>
                            )}

                            <RadarGrid
                                history={gameData.history}
                                deployedTraps={gameState === 'planning' ? [] : inputs.map(i => ({ x: Number(i.x), y: Number(i.y) }))}
                                zombiePath={gameState !== 'planning' ? gameData.future : null}
                                gridSize={GRID_SIZE}
                            />
                        </div>

                        {/* Right: Control Panel */}
                        <div className="bg-green-900/10 border border-green-800 p-6 rounded-lg backdrop-blur-sm shadow-xl">
                            <div className="mb-6">
                                <h2 className="text-xl font-bold flex items-center gap-2 mb-2">
                                    <CrosshairIcon /> TACTICAL PREDICTION
                                </h2>
                                <p className="text-sm text-green-600 font-mono border-l-2 border-green-700 pl-3">
                                    Subject moving in linear pattern. <br />
                                    Known locations:
                                    {gameData.history.map((pt, i) => <span key={i} className="text-green-300 ml-2">({pt.x},{pt.y})</span>)}
                                </p>
                            </div>

                            {/* Inputs */}
                            <div className="space-y-4 mb-8">
                                {inputs.map((inp, idx) => (
                                    <div key={idx} className="flex items-center gap-4 bg-black/40 p-3 rounded border border-green-900/50">
                                        <span className="font-pixel text-2xl text-green-500 w-8">#{idx + 1}</span>
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs text-green-700">X:</span>
                                            <input
                                                type="text"
                                                maxLength="2"
                                                value={inp.x}
                                                onChange={(e) => handleInputChange(idx, 'x', e.target.value)}
                                                className="coord-input rounded"
                                                placeholder="?"
                                                disabled={gameState !== 'planning'}
                                            />
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs text-green-700">Y:</span>
                                            <input
                                                type="text"
                                                maxLength="2"
                                                value={inp.y}
                                                onChange={(e) => handleInputChange(idx, 'y', e.target.value)}
                                                className="coord-input rounded"
                                                placeholder="?"
                                                disabled={gameState !== 'planning'}
                                            />
                                        </div>
                                        {gameState === 'planning' && <span className="text-xs text-green-800 animate-pulse ml-auto">PENDING</span>}
                                        {(gameState === 'secure' || gameState === 'breach') && (
                                            <span className="ml-auto">
                                                {parseInt(inp.x) === gameData.future[idx].x && parseInt(inp.y) === gameData.future[idx].y
                                                    ? <span className="text-green-400">HIT</span>
                                                    : <span className="text-red-500">MISS</span>}
                                            </span>
                                        )}
                                    </div>
                                ))}
                            </div>

                            {/* Status / Controls */}
                            <div className="border-t border-green-800 pt-4">
                                <div className={`text-center font-mono text-sm mb-4 p-2 rounded ${gameState === 'breach' ? 'bg-red-900/20 text-red-400' :
                                        gameState === 'secure' ? 'bg-green-900/20 text-green-300' : 'text-green-500'
                                    }`}>
                                    {feedback}
                                </div>

                                {gameState === 'planning' && (
                                    <button
                                        onClick={deployTraps}
                                        className="w-full bg-green-700 hover:bg-green-600 text-black font-bold py-4 rounded shadow-[0_4px_0_rgb(20,83,45)] active:shadow-none active:translate-y-1 transition-all uppercase tracking-widest font-pixel text-2xl"
                                    >
                                        Deploy Traps
                                    </button>
                                )}
                                {gameState === 'secure' && (
                                    <button
                                        onClick={nextMission}
                                        className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded shadow-[0_4px_0_rgb(30,58,138)] active:shadow-none active:translate-y-1 transition-all uppercase tracking-widest font-pixel text-2xl"
                                    >
                                        Next Wave
                                    </button>
                                )}
                                {gameState === 'breach' && (
                                    <button
                                        onClick={retryMission}
                                        className="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-4 rounded shadow-[0_4px_0_rgb(127,29,29)] active:shadow-none active:translate-y-1 transition-all uppercase tracking-widest font-pixel text-2xl"
                                    >
                                        System Reset
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Decorative Scanlines */}
                    <div className="fixed inset-0 pointer-events-none z-0 bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.25)_50%),linear-gradient(90deg,rgba(255,0,0,0.06),rgba(0,255,0,0.02),rgba(0,0,255,0.06))] bg-[length:100%_2px,3px_100%] pointer-events-none"></div>

                    <div className="mt-8 text-green-800 text-xs font-mono z-10 text-center">
                        <p>Skill Target: LL.7 (Analyze Graphed Relationships)</p>
                        <p className="mt-1">WARNING: Zombie mutation rate increases with level.</p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>